{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"算法练习4:买卖股票的最佳时机（简单）","slug":"买卖股票的最佳时机（简单）","date":"2020-06-06T13:04:01.000Z","updated":"2021-07-05T14:37:14.918Z","comments":true,"path":"2020/06/06/买卖股票的最佳时机（简单）/","link":"","permalink":"http://example.com/2020/06/06/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/","excerpt":"","text":"题目&emsp;给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 示例1 输入: [7,1,5,3,6,4]输出: 5注释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例2 输入：prices = [7,6,4,3,1]输出：0解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 解题思路:&emsp;通过动态规划，我们可以看出购买股票存在3种状态。第一种状态为从始至终都未购买股票，即dp1 = 0。第二种状态为买入了股票但是没有卖出(初始状态假设第一天买入，因为买入相当于亏损，所以取负值)，即dp2 = -prices[0]。第三种状态为买入又卖出状态（假设最终亏损巨大，取负无穷），即dp3 = float(“-inf”)。因为股票第一天不可能卖出，所以我们的循环从第二天开始。首先对比买入状态目前的价格和（未购买价格与当天价格）的最大值，即亏损最少的买入值。其次对比卖出状态的价格和（目前已亏损价格和当天价格的和）的最大值，即盈利最大值。最终对比盈利值是否大于0，大于0则取盈利值，如果小于0则取不操作值（0）。 代码:123456789class Solution: def maxProfit(self, prices: List[int]) -&gt; int: dp1 = 0 dp2 = -prices[0] -7 dp3 = float(&quot;-inf&quot;) for i in range(1, len(prices)): dp2 = max(dp2, dp1 - prices[i]) dp3 = max(dp3, dp2 + prices[i]) return max(dp1, dp3) 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"pyinstaller打包pymzml时遇到的错误及解决办法","slug":"pyinstaller打包pymzml时遇到的错误及解决办法","date":"2020-06-05T14:15:19.000Z","updated":"2021-07-05T14:31:06.524Z","comments":true,"path":"2020/06/05/pyinstaller打包pymzml时遇到的错误及解决办法/","link":"","permalink":"http://example.com/2020/06/05/pyinstaller%E6%89%93%E5%8C%85pymzml%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%94%99%E8%AF%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"","text":"问题环境&emsp;工作中因为需要分析质谱仪器产生的相关数据，并对数据进行数据处理分析，所以需要使用pymzml包。而当对质谱分析软件进行打包时，由于pymzml相关obo文件代码和Pyinstaller对pymzml包的支持问题，产生了一些报错。（特此记录相关解决方式） 报错问题11FileNotFoundError: [Errno 2] No such file or directory: &#x27;D:\\\\workspace\\\\app\\\\dist\\\\app\\\\pymzml\\\\version.txt&#x27; 解决方法 pyinstaller包中hooks文件夹中创建hook-pymzml.py文件，里面写入如下代码: 12from PyInstaller.utils.hooks import collect_data_filesdatas = collect_data_files(&#x27;pymzml&#x27;) 报错问题2&emsp;pyinstaller未打包时对于MZML文件的解析可以正常进行，但是打包后文件解析会报错在pymzml包中的obo.py文件的168行。（由于忘记记录错误，所以此处不展示报错信息） 解决方法&emsp;通过代码报错信息和代码发现，打包后obo.py文件找不到obo_root的完整路径，所以我们可以通过代码改写，拼写obo_root的完整路径，代码如下（代码放入obo.py文件的169行）： 12if os.path.exists(os.path.join(obo_root, &quot;obo&quot;)) == False: obo_root = os.path.join(obo_root, &quot;pymzml&quot;) 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[],"tags":[{"name":"pyinstaller","slug":"pyinstaller","permalink":"http://example.com/tags/pyinstaller/"},{"name":"pymzml","slug":"pymzml","permalink":"http://example.com/tags/pymzml/"}]},{"title":"算法练习3：移动零（简单）","slug":"移动零","date":"2020-06-03T15:46:53.000Z","updated":"2021-07-05T14:00:41.980Z","comments":true,"path":"2020/06/03/移动零/","link":"","permalink":"http://example.com/2020/06/03/%E7%A7%BB%E5%8A%A8%E9%9B%B6/","excerpt":"","text":"题目&emsp;给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序 示例1 输入: [0,1,0,3,12]输出: [1,3,12,0,0] 提示 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 解题思路（双指针方法）:&emsp;使用双指针，右指针指向的位置为还未被0替换的位置。左指针表示还未经过判断是否为0的元素。当左指针发现元素为0，则将元素拿出放入数组末尾，同时使得右指针左移1位，指向下一个未被替换为0的元素。当指针发现元素不为0，则将左指针右移一位，指向下一个未被判断的元素。当两个指针碰撞时，终止循环。 代码:1234567891011121314class Solution: def moveZeroes(self, nums: List[int]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums in-place instead. &quot;&quot;&quot; left = 0 right = len(nums) - 1 while left &lt; right: if nums[left] == 0: nums.append(nums.pop(left)) right -=1 else: left +=1 return nums","categories":[],"tags":[{"name":"双指针","slug":"双指针","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法练习2：合并两个有序数组（简单）","slug":"合并两个有序数组","date":"2020-06-02T14:52:50.000Z","updated":"2021-07-05T14:00:37.172Z","comments":true,"path":"2020/06/02/合并两个有序数组/","link":"","permalink":"http://example.com/2020/06/02/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/","excerpt":"","text":"题目&emsp;给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。 示例1 输入: nums1 = [1], m = 1, nums2 = [], n = 0输出: [1] 示例2 输入: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6] 提示&emsp;本题无需任何返回，要求在原有数组nums1中对数组进行修改，最后使得数组nums1符合题目要求 解题思路（双指针方法）:&emsp;我们设定三个指针。分别为nums1的非0元素的末尾m,nums2的末尾n,nums1数组的末尾k。我们对指针m上的值和指针n上的值进行比较，若指针n上的值大于指针m上的值，那么我们就把指针n上的值赋值给指针k上的值。同时指针k和指针n向前移动一位。若指针n上的值小于等于指针m上的值，那么我们就把指针m上的值赋值给指针k上的值，同时指针k和指针m向前移动一位。直到m和n指针有一个为0，循环结束。因为两个数组为有序数组，所以最后将剩余未移动的nums2剩余的数组直接放置到nums1数组前即可。 代码:123456789101112131415class Solution: def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None: &quot;&quot;&quot; Do not return anything, modify nums1 in-place instead. &quot;&quot;&quot; k = m + n - 1 while m &gt; 0 and n &gt; 0: if nums2[n - 1] &gt; nums1[m - 1]: nums1[k] = nums2[n - 1] n -= 1 else: nums1[k] = nums1[m - 1] m -= 1 k -= 1 nums1[:n] = nums2[:n] 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[],"tags":[{"name":"双指针","slug":"双指针","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法练习1：存在重复元素问题（简单）","slug":"算法练习1：存在重复元素问题（简单）","date":"2020-06-01T14:34:52.000Z","updated":"2021-07-01T17:06:07.857Z","comments":true,"path":"2020/06/01/算法练习1：存在重复元素问题（简单）/","link":"","permalink":"http://example.com/2020/06/01/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A01%EF%BC%9A%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E9%97%AE%E9%A2%98%EF%BC%88%E7%AE%80%E5%8D%95%EF%BC%89/","excerpt":"","text":"题目&emsp;给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。示例1 输入: nums = [1,2,3,1], k = 3输出: true 示例2 输入: nums = [1,0,1,1], k = 1输出: true 示例3 输入: nums = [1,2,3,1,2,3], k = 2输出: false 解题思路:&emsp;通过 enumerate函数获得数组中的值和下标，创建一个字典用于存储遍历的数据。因为数组的值会重复，但是下标位置不会重复。所以，将值作为字典的key,对应的下标位置作为值存入字典中。循环遍历数组时，判断值是否重复（KEY是否存在），会出现以下三种情况：&emsp;&emsp;1：key不存在&emsp;&emsp;2：key存在，但大于k&emsp;&emsp;3：key存在，小于等于K遇到第一种情况：说明未发现重复值，则将值和下标分别作为 Key value 写入。遇到第二种情况：说明发现了重复值，但是不符合规则，说明之后即使再发现有重复值也不可能小于key了，但是有可能后面会有其他重复值与当前未写入到dic中的值符合要求。所以更新当前的值和下标放入dic中。若所有循环都走完仍未发现符合的值，则返回FALSE。遇到第三种情况：说明发现重复值且符合规则，则直接终止返回TRUE。 代码:123456789101112class Solution: def containsNearbyDuplicate(self, nums: List[int], k: int) -&gt; bool: dic = &#123;&#125; for position, value in enumerate(nums): if value in dic.keys(): if abs(dic[value] - position) &gt; k: dic[value] = position else: return True else: dic[value] = position return False 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"pyinstaller","slug":"pyinstaller","permalink":"http://example.com/tags/pyinstaller/"},{"name":"pymzml","slug":"pymzml","permalink":"http://example.com/tags/pymzml/"},{"name":"双指针","slug":"双指针","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]}